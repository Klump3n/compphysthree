\documentclass[10pt,a4paper]{article}
%]{report}

\usepackage[a4paper, top=2cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
%\usepackage[  
%    vmarginratio=2:2.5, %Verhï¿½ltnis der oben/unten Seitenrï¿½nder zur automatischen Berechnung
%    paper=a4paper,
%    lmargin=3cm, % mittlerer Rand
%    rmargin=3cm, % ï¿½uï¿½erer Rand
%    marginparwidth=2.3cm, % Breite des Marginpars
%    includehead, % Kopfzeile in Berechnung einbeziehen
%    includemp % Marginpar in die Berechnung mit einbeziehen
%]{geometry}
%\setlength\marginparwidth{2.3cm} %Die wird spï¿½ter zum Rechnen gebraucht, wird aber durch die Angabe im geometry package nicht automatisch richtig gesetzt.


%============================================================
% Pakete
%============================================================

\usepackage[english, ngerman]{babel}    % mehrsprachiger Textsatz
% babel: letzte Sprache in Optionen zeigt die Sprache des Dokumentes
% und kann durch den Befehl \selectlanguage{} geaendert werden
% Passen Sie die Optionen des babel-Paketes nach Bedarf an!
\usepackage[utf8]{inputenc}       % Eingabekodierung Parameter latin1 darf geï¿½ndert werden
\usepackage[T1]{fontenc}                % Schriftenkodierung
\usepackage{graphicx}                       % zum Einbinden von Grafiken
\usepackage{lmodern}                        % Ersatz fuer Computer Modern-Schriften
                                                                % zum besseren Aussehen am Bildschirm
\usepackage{epstopdf}		% Grafiken einbinden
\usepackage{caption}		%Grafiken beschriften
%\usepackage{verbatimfiles}	% Ganze Dateien als Verbatim einbinden
% \usepackage{programs}	% Ganze Dateien als Verbatim einbinden
\usepackage{verbatim}		% Mehrzeilige Kommentare
\usepackage{multicol}		% Mehrere Spalten
\usepackage{hyphsubst}		% Silbentrennung
\usepackage{xcolor,soul}
\usepackage{float}				%Sachen an der richtigen Stelle ausgeben
\restylefloat{figure}				%Abbildungen an der richtigen Stelle ausgeben
\restylefloat{table}				%Tabellen an der richtigen Stelle ausgeben
\usepackage{array}				%fï¿½r Tabellen
\newcolumntype{C}{>{$}c<{$}} 	%Tabellenspalten C mit mathematischem Inhalt
\usepackage{subfigure}
\usepackage{ulem}				%doppelt unterstreichen
\usepackage{siunitx}
\usepackage{hyperref}
\usepackage{booktabs}


\usepackage{etex} %needs to be used to avoid 'no room error in pgfplots'
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{tikz-3dplot}
%\usepackage{tikzscale}
\usepgfplotslibrary{polar}
\usetikzlibrary[pgfplots.colormaps]
\pgfplotsset{compat=newest}
\pgfplotsset{plot coordinates/math parser=false}
\newlength\figureheight
\newlength\figurewidth
%\pgfplotsset{y tick label style={/pgf/number format/fixed}}
%\pgfplotsset{yticklabel style={text width=2.2em,align=right}}%,fixed zerofill, precision=1}}
%\pgfplotsset{every x tick/.append style={line width=1pt}}
%\pgfplotsset{every y tick/.append style={line width=1pt}}
%\pgfplotsset{every axis plot/.append style={line width=1.0pt}}
%\pgfplotscreateplotcyclelist{mycolorlist}{blue,red,green,brown,teal,orange,violet,cyan,green!70!black,magenta,gray}

\usepackage{tikzscale}
\usetikzlibrary{external}
\usetikzlibrary{fadings}
\usetikzlibrary{arrows}
\usetikzlibrary{calc}
\usetikzlibrary{plotmarks}
\usepgfplotslibrary{external}
\tikzset{external/force remake=false}
\tikzset{external/system call={pdflatex \tikzexternalcheckshellescape -halt-on-error -interaction=batchmode -jobname "\image" "\texsource"}}

\tikzexternalize

% define colors for source code list
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{0,1,0.3}
%\definecolor{colString}{rgb}{0,0.5,0}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{colString}{rgb}{0.63,0.13,0.94}

% Code-Listings print source code
\usepackage{listings}
\lstset{language=Python,		% choose the language of the code
	inputencoding=latin1,
	keywords={break,case,catch,continue,else,elseif,end,for,function,
	 global,if,otherwise,persistent,return,switch,try,while,ones,zeros},
   	float=hbp,
%  	 basicstyle=\ttfamily\small,				% the size of the fonts that are used for the code
   	identifierstyle=\color{colIdentifier},
   	keywordstyle=\color{blue},
   	commentstyle=\color{dkgreen},
  	stringstyle=\color{colString},
   	columns=flexible,
  	tabsize=2,								% sets default tabsize to 2 spaces
   	%frame=none; %single,
  	 numbers=left,						% where to put the line-numbers
  	 showspaces=false,                               % show spaces adding particular underscores
  	 numberstyle=\ttfamily\small\color{gray},
% numberstyle=\footnotesize,                      % the size of the fonts that are used for the line-numbers
  	 stepnumber=1,                                           % the step between two line-numbers. If it's 1 each line will be numbered
  	 numbersep=10pt,                                  % how far the line-numbers are from the code
  	 showspaces=false,
  	 showstringspaces=false,                         % underline spaces within strings
  	 breakautoindent=true,                        % sets if automatic breaks should only happen at whitespace
%       backgroundcolor=\color{white},          % choose the background color. You must add \usepackage{color}
%  	     showtabs=false,                                         % show tabs within strings adding particular underscores
%       frame=single,                                           % adds a frame around the code
%       captionpos=b,                                           % sets the caption-position to bottom
%        escapeinside={\%*}{*)                          % if you want to add a comment within your code
        breaklines=true}                                       % sets automatic line breaking

% Mathe-Pakete
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}		% Theorem-Umgebung, Beweise
\usepackage{amssymb}
\usepackage{cancel}
\usepackage{mathcomp}
\usepackage{nicefrac}

\usepackage{libertine}
\usepackage[libertine]{newtxmath}

%============================================================
% Titel, Autor, Datum
%============================================================
\title{Übung 2 \\Computational Physics III}
\author{Matthias Plock (552335) \and Paul Ledwon (561764)}
\date{\today}

%============================================================
% Dokument
%============================================================
\begin{document}

% Titel erstellen
\maketitle
\tableofcontents

\pagenumbering{arabic}
\pagestyle{myheadings}                  % bzw. ist fancyhdr zu benutzten

\section{Aufgabe 1}

\subsection{Einleitung}

Implementiert wird die Methode der Konjugierten Gradienten aus Übung 1 in der
Programmiersprache \texttt{C}.

Im Folgenden wird auf die drei Teilaufgaben eingegangen.

\subsection{Implementierung des Matrix-Vektor-Produktes für den Laplace
  Operator}

Zu implementieren war das Matrix-Vektor-Produkt
\begin{align*}
  w = Av \,,
\end{align*}
wobei $A$ der Laplace-Operator ist und $v$ ein Vektor mit Unbekannten.
Bei einer Problemgröße von $N\times N$ hat $A$ die Dimension $(2N+2)\times
(2N+2)$, $v$ hat die Dimension $2 (2N+2)$. Die extra Dimensionen tauchen auf, da
die Randbedingungen mit einbezogen werden.

Die Implementierung ist in der Funktion \texttt{void laplace\_2d(double *w,
  double *v)} zu finden.

Die Funktion wird einen Unbekannten-Vektor $v$ (Abb. \ref{fig:v}) aufgerufen,
das Resultat in die Shell ausgegeben (Abb. \ref{fig:w}).

\begin{figure}[H]
  \centering
\begin{verbatim}
v = 
  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 
  0.00 10.30 19.80 10.50 11.50 8.10 25.50 7.40 23.60 0.00 
  0.00 4.10 20.50 18.60 17.10 24.20 25.10 22.70 7.00 0.00 
  0.00 12.40 19.40 8.40 24.80 2.70 23.20 23.10 14.10 0.00 
  0.00 11.80 9.00 4.60 9.90 5.10 15.90 20.10 15.40 0.00 
  0.00 10.20 5.00 1.30 18.30 4.90 8.80 16.30 9.00 0.00 
  0.00 3.70 9.30 0.50 2.30 8.80 23.30 9.40 21.20 0.00 
  0.00 17.10 17.80 20.50 19.80 15.50 18.00 8.40 1.70 0.00 
  0.00 1.40 13.00 11.60 6.50 3.30 6.10 22.00 13.50 0.00 
  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 
||v|| = 118.21852647
\end{verbatim}
  \caption{Der Unbekannten-Vektor $v$.}
  \label{fig:v}
\end{figure}

\begin{figure}[H]
  \centering
\begin{verbatim}
w = 
  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 
  0.00 -17.30 -37.90 7.90 -10.30 28.80 -61.40 42.20 -80.00 0.00 
  0.00 26.80 -20.10 -17.90 10.70 -43.80 -4.80 -28.20 32.40 0.00 
  0.00 -14.30 -27.30 33.80 -61.10 66.50 -26.00 -12.30 -10.90 0.00 
  0.00 -15.60 4.80 10.20 13.20 13.00 -6.40 -9.70 -18.40 0.00 
  0.00 -20.30 9.80 23.20 -54.80 21.40 25.20 -17.90 16.90 0.00 
  0.00 21.80 -10.20 31.40 38.20 10.80 -48.20 31.60 -64.70 0.00 
  0.00 -45.50 -11.30 -32.30 -34.40 -12.10 -18.70 17.50 36.30 0.00 
  0.00 24.50 -21.20 -6.40 8.70 14.90 18.90 -60.00 -30.30 0.00 
  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 
||w|| = 248.22340744
\end{verbatim}
  \caption{Resultat des Funktionsaufrufs \texttt{void laplace\_2d(double *w,
  double *v)} mit dem Unbekannten-Vektor $v$.}
  \label{fig:w}
\end{figure}

Um das Resultat zu verifizieren wenden wir den Laplace-Operator auf den
Unbekannten-Vektor $v$ (ohne die Randbedingungen) an. Das Resultat ist in Abb.
\ref{fig:verify} zu finden.

\begin{figure}[H]
  \centering
\begin{verbatim}
[[-17.3 -37.9   7.9 -10.3  28.8 -61.4  42.2 -80. ]
 [ 26.8 -20.1 -17.9  10.7 -43.8  -4.8 -28.2  32.4]
 [-14.3 -27.3  33.8 -61.1  66.5 -26.  -12.3 -10.9]
 [-15.6   4.8  10.2  13.2  13.   -6.4  -9.7 -18.4]
 [-20.3   9.8  23.2 -54.8  21.4  25.2 -17.9  16.9]
 [ 21.8 -10.2  31.4  38.2  10.8 -48.2  31.6 -64.7]
 [-45.5 -11.3 -32.3 -34.4 -12.1 -18.7  17.5  36.3]
 [ 24.5 -21.2  -6.4   8.7  14.9  18.9 -60.  -30.3]]
\end{verbatim}
  \caption{Anwendung des Laplace-Operators aus dem letzten Übungsblatts auf den
    Unbekannten-Vektor $v$ (ohne Randbedingungen).}
  \label{fig:verify}
\end{figure}

Vergleich der Abbildungen \ref{fig:w} und \ref{fig:verify} zeigt, dass die
implementierte Methode das selbe Resultat liefert, wie die Methode der letzten
Übung.

\subsection{Implementierung von Hilfsfunktionen}

Es wurden Hilfsfunktionen implementiert um ein Skalarprodukt zu berechnen
(\texttt{double scalar\_product(double *u, double *v)}), um
zwei Vektoren zu addieren (\texttt{void vector\_addition(double *u, double *v,
  double *w)}) sowie um einen Vektor zu skalieren (\texttt{void
  scale\_vector(double prefactor, double *v, double *w)}).

\subsection{Implementierung der Methode der Konjugierten Gradienten}

In \texttt{void conjugate\_gradient\_laplace(double *x, double *b)} ist die
Methode der Konjugierten Gradienten implementiert. Mit ihr wird das $x$ zum
Unbekannten-Vektor $v$ aus Abb. \ref{fig:v} bestimmt. Das Resultat konvergiert
nach 27 Schritten (Konvergenz wird angenommen, wenn das Residuum $\|r\| <
\num{1e-15}$ ist) und ist in Abb. \ref{fig:converged_x} zu finden.

\begin{figure}[H]
  \centering
\begin{verbatim}
tol (1.741376e-16 < 1.000000e-15) reached after 27 steps
x = 
  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 
  0.00 -15.24 -27.67 -31.78 -34.98 -36.26 -38.40 -29.25 -20.28 0.00 
  0.00 -22.97 -43.87 -53.98 -60.39 -63.53 -62.61 -50.92 -28.28 0.00 
  0.00 -28.66 -50.38 -61.26 -71.96 -70.69 -72.48 -60.84 -34.93 0.00 
  0.00 -28.91 -48.31 -60.34 -70.69 -72.07 -72.60 -61.91 -36.50 0.00 
  0.00 -26.86 -44.60 -56.51 -68.50 -69.20 -68.02 -57.63 -33.75 0.00 
  0.00 -23.72 -41.72 -51.31 -59.28 -63.32 -63.84 -50.52 -31.89 0.00 
  0.00 -22.60 -37.96 -47.23 -51.71 -52.15 -50.22 -39.32 -22.08 0.00 
  0.00 -11.63 -22.50 -27.43 -28.37 -27.84 -27.56 -26.07 -15.41 0.00 
  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 
||x|| = 381.97886569
\end{verbatim}
  \caption{$x$ zum Unbekannten-Vektor $v$ aus Abb. \ref{fig:v}, berechnet mit
    der Methode der Konjugierten Gradienten.}
  \label{fig:converged_x}
\end{figure}

Das Resultat wird mit der Python-Implementierung aus Übung 1 verifiziert (Abb.
\ref{fig:python_x}).

\begin{figure}[H]
  \centering
\begin{verbatim}
[[-15.24 -27.67 -31.78 -34.98 -36.26 -38.4  -29.25 -20.28]
 [-22.97 -43.87 -53.98 -60.39 -63.53 -62.61 -50.92 -28.28]
 [-28.66 -50.38 -61.26 -71.96 -70.69 -72.48 -60.84 -34.93]
 [-28.91 -48.31 -60.34 -70.69 -72.07 -72.6  -61.91 -36.5 ]
 [-26.86 -44.6  -56.51 -68.5  -69.2  -68.02 -57.63 -33.75]
 [-23.72 -41.72 -51.31 -59.28 -63.32 -63.84 -50.52 -31.89]
 [-22.6  -37.96 -47.23 -51.71 -52.15 -50.22 -39.32 -22.08]
 [-11.63 -22.5  -27.43 -28.37 -27.84 -27.56 -26.07 -15.41]]
\end{verbatim}
  \caption{$x$ berechnet mit der Python-Implementierung.}
  \label{fig:python_x}
\end{figure}

Vergleich der Abbildungen \ref{fig:converged_x} und \ref{fig:python_x} zeigt,
dass die implementierte Methode des selbe Ergebnis liefert, wie die Python
Implementierung des letzten Übungsblattes.

\section{Aufgabe 2}
	
	Die Datei addArrayHost.cu wurde so erweitert, dass für verschiedene Arraygrößen
	die Latenz der Kopiervorgänge zwischen Host und Device, deren Bandbreite und 
	der Durchsatz von Host und Device berechnet wurde. Die Arraygrößen für die 
	diese Größen berechnet wurden, lagen zwischen $10^{7}$ und $6 \cdot 10^{7}$.
	Führt man die Datei aus, die aus addArrayHost.cu kompiliert wird, erhält man
	als Output die oben genannten Größen für alle Arraygrößen. Diesen Outputs kann
	man entnehmen, dass für die getesteten Arrays unterschiedlicher Dimension
	bereits recht konstante Werte für Durchsatz und Bandbreite erreicht werden.

	\begin{verbatim}
		test
	\end{verbatim}

\end{document}
